#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//算数操作符
int main()
{
    int a = 7 / 2;
    float b = 7.0 / 2;//浮点型除法
    int c = 7 % 2;//取模操作符的两端必须是整数
    printf("%d\n", a);
    printf("%f\n", b);
    printf("%d\n", c);

    return 0;
}

/*
* 整形的数据存储
整数的二进制表示有三种:原码 反码 补码
正整数的原码 反码 补码相同；负的整数需要计算

7的原码00000000000000000000000000000111  4个字节 一个字节8个比特位
7的反码 补码相同
       首位(符号位)表示正负:正数0 负数1
-7的原码10000000000000000000000000000111
-7的反码11111111111111111111111111111000 原码的符号位不变其他按位取反1变0 0变1
-7的补码11111111111111111111111111111001 反码加1

整数在内存中存储的是二进制的补码
*/

/*
* 位运算符
<<左移操作符 左边丢弃 右边补0
>>右移操作符 右边丢弃 左边补原符号位
*/
int main()
{
    int a = 7;
    //移位操作符 移动的是内存中的补码
    int b = a << 1;//左移操作符 a的补码向左移动1位 右边丢了移位补0
    //移动的是二进制位
    printf("%d\n", a);
    printf("%d\n", b);

    int c = 7;
    int d = c >> 1;//右移操作符：右边丢弃左边补原号位

    return 0;
}

int main()
{
    int a = 3;
    printf("%d\n", ~a);//补码 0变1 1变0

    return 0;
}

int main()
{
    int a = 13;
    //1101
    //1101变成1111
    a |= (1 << 1);//将0001向左移动一位 再按位或
    printf("%d\n", a);

    a &= (~(1 << 3));//吧1101改成0101
    printf("%d\n", a);

    return 0;
}

/*
* 位运算符
& 按（二进制）位与   有0则0 都1才1
| 按（二进制）位或   有1则1 都0才0
^ 按（二进制）位异或  相同为0 相异为1
只适用于整形或字符型
*/
int main()
{
    int a = 3;
    int b = -5;
    int c = a & b;
    //00000000000000000000000000000011 3的补码
    //11111111111111111111111111111011 -5的补码
    //按位与补码结果
    //00000000000000000000000000000011 有0则0 都1才1
    printf("%d\n", c);

    int d = 3;
    int e = -5;
    int f = d ^ f;
    printf("%d\n", f);
    //异或结果
    //00000000000000000000000000000111 相同为0 相异为1

    return 0;
}

/*
按位与的用途： 
1.想让a的从右数第四个比特位变0
找b(第四个位为0 其他为1) 
a:0 0 1 0 1 0 1 1
b:1 1 1 1 0 1 1 1
&:0 0 1 0 0 0 1 1

2.取出a的低四位
找b(第四位为1 其他为0)
a:0 0 1 0 1 0 1 1
b:0 0 0 0 1 1 1 1
&:0 0 0 0 1 0 1 1
*/
/*
按位异或的用途
1.是特定位翻转，即0变1 1变0
让a低4位翻转,找b(低四位位1 其他位0)
a:0 1 1 1 1 0 1 0
b:0 0 0 0 1 1 1 1
^:0 1 1 1 0 1 0 1

2.a^0=a
*/
/*
按位取反的用途
让a的最低一位变0
a&(~1)
*/

// 交换两个数字
int main()
{
    int a = 3;
    int b = 5;

    /*
        a=a+b;
        b=a-b;
        a=a-b;
        //整形有上限
    */
    /*
        n^n=0 
        n^0=n
        按位异或支持交换律 5^5^3=5^3^5
    */

    a = a ^ b;//3^5
    b = a ^ b;//3^5^5--3
    a = a ^ b;//3^5^3--5

    return 0;
}

int main()
{
    int a = 0;
    scanf("%d", &a);
    int i = 0;
    int count = 0;
    for (i = 0; i < 32; i++)
    {
        if (a & 1 == 1)
        {
            count++;
        }
        a = a >> 1;
    }
    printf("%d", count);

    return 0;
}

//区分按位与和逻辑与
int main()
{
    int a = 5;
    int b = 3;
    int c = a && b;//逻辑与 真&&真 即真
    int d = a || b;//逻辑或 只要有一个真则结果为真
    printf("%d\n", c);//c真为1

    return 0;
}

//&& 左边为假 右边就不计算了
//|| 左边为真 右边就不计算了
int main()
{
    /*
    int i=0,a=0,b=2,c=3,d=4;
    i=a++ && ++b && d++;//a++ 后置++ 先使用a=0后面都为假不需要读取
    */

    int i = 0, a = 1, b = 2, c = 3, d = 4;
    i = a++ || ++b || d++;//a先使用为真 后面都真不需要读取
    printf("a=%d b=%d c=%d d=%d", a, b, c, d);

    return 0;
}

void test1(int arr[])//传参传的是首元素的地址
{
    printf("%d\n", sizeof(arr));//指针字节大小4或者8
}

void test2(char ch[])//指针
{
    printf("%d\n", sizeof(ch));//本质也是指针字节大小4或8
}

int main()
{
    int arr[10] = { 0 };
    char ch[10] = { 0 };
    printf("%d\n", sizeof(char));//存储字符 占用1个字节
    printf("%d\n", sizeof(int));//存储整形 占用4个字节
    printf("%d\n", sizeof(arr));//40
    printf("%d\n", sizeof(ch));//10

    test1(arr);
    test2(ch);

    return 0;
}

int main()
{
    char a = 126;
    char b = 5;
    char c = a + b;
    /*
    c的整型算术运算总是至少以默认的整型类型精度进行
    因此 将整形提升:字符和短整型操作数在使用之前被转换为普通整形
    a的char内存为00000101 提升00000000000000000000000000000101
    b的char内存为01111110 提升00000000000000000000000001111110
    a b相加之后为             00000000000000000000000010000011
    字符型c内存为10000011
    首位为1负数 高位补齐1     11111111111111111111111110000011补码
                              11111111111111111111111110000010反码
                              10000000000000000000000001111101原码
    */

    printf("%d", c);//-125

    return 0;
}


int main()
{
    char a = 1;
    printf("%u\n", sizeof(a));//1
    printf("%u\n", sizeof(+a));//4 整型提升
    printf("%u\n", sizeof(-a));//4 整型提升

    return 0;
}

/*
a* b + c * d + e * f
此表达式按照优先级具有多个路径 属于问题表达式

int c=2;
c + --c;
第一个c可能为1 也可能为2 此表达式为问题表达式

int a=1;
int b=(++a)+(++a)+(++a);
表达式错误 (3+3)+4 或者(4+4+4);
*/
int fun()
{
    static int count = 1;
    return ++count;
}
int main()
{
    int answer;
    answer = fun() - fun() * fun();
    //只能确定符号优先级 无法确定好函数调用顺序
    printf("%d\n", answer);

    return 0;
}
